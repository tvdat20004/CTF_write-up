from sage.all import GF, is_prime_power, gcd
from Crypto.Cipher import AES 
from Crypto.Util.number import long_to_bytes
from hashlib import sha256

n = 875160154252520186251141359813376844205078837688859219647998263059390545455666959868272831956779132045330105458640460325486680058028233270020291614157451317894110269639780507518860757299450578151147748572019371950843986400076289065334864577087504297359676338166424192877389197803442490978821375794048316553853085966558794240760959161987598108459441945291723309230665829568115073301763544532552179053221908864303864014278134933463597319119189753348991487712539547783209384907074459767339389912999640300731884080101606842315180302622347685382825488775275363493924203654141256657466019975768214244502429057343992946031175889606627829209702720334661107181627261133702840164098042293465302874342367
s = [45948196110742333078791904670754464213578139076280109814760521831353273605782767324779081189039031009815013571451298379981707915542440414220083426012609548317078548002379773850309022768943249397294154504631709396600886029113258544, 665421018479354408650321321446504004021595291664664613059639369284378526681870680990726015080235767661978417143890017835302285399955943814186163819783105747360598346167878408804511855184450139017542601099343516459031570045750334635, 116901116055486713179543809270968616175254891027356317875260251653063459332706332539151662885597749087527500088196623717000607610204151297409257838680010556067036481294394312559141590536968964270065614095041734217016802912127551399, 257185387102952423422505329148493981831897715690584197952849048768011651303898015179171902245107615610642197589412557491017458513344338002354160349045327465820185865360211004133692933165886876481285477189851986291296987966454584913, 600597039831835988459465667623398229366883082253281715825043750022005882279772326647162809398726368298023180858058246314753665389921411839577046046481816334727242911521098595075675355340100111145925656700034968689114367721111389240]
enc_flag = bytes.fromhex('df534b412fbbb5bf920a9c8a76f85013b2c6cb49642c30a7e5e801f9576b4f36071945f46d3e78c8b1e2adff0c090d7d88e9a068caae958d87ca56bcd0763e00e527371f271530bd6bb779284233ec45')
def recover_lcg(y):
    assert len(y) >= 4, "At least 4 outputs are required to recover the modulus"
    # m = None
    # for i in range(len(y) - 3):
    #     d0 = y[i + 1] - y[i]
    #     d1 = y[i + 2] - y[i + 1]
    #     d2 = y[i + 3] - y[i + 2]
    #     g = d2 * d0 - d1 * d1
    #     m = g if m is None else gcd(g, m)
    #     print(m)
    m = 1030202629312433135327084697782451434193258323511212902787034456401463370727939744550247897489051002189348437608753724232333239724019582799808830091231032935275252320440759358927762962034314198351871525704407883005491242720100739229
    assert m.bit_length() == 768
    gf = GF(m)
    x0 = gf(y[0])
    x1 = gf(y[1])
    x2 = gf(y[2])
    a = int((x2 - x1) / (x1 - x0))
    x0 = gf(y[0])
    x1 = gf(y[1])
    c = int(x1 - a * x0)

    return m, a, c

r, p, q = recover_lcg(s)
assert is_prime_power(r) and is_prime_power(p) and is_prime_power(q) and p*q*r == n 

d = pow(65537, -1, (p-1)*(q-1)*(r-1))

key = sha256(long_to_bytes(d)).digest()
cipher = AES.new(key, AES.MODE_ECB)

flag = cipher.decrypt(enc_flag)
print(flag)